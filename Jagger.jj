// Options for JavaCC.
options { LOOKAHEAD=1; FORCE_LA_CHECK=true; }

// Fonction principale
PARSER_BEGIN(Jagger)
public class Jagger
{
    public static void main(String args[]) throws ParseException
    {
        Jagger parser = new Jagger(System.in);
        parser.mainloop();
    }
}
PARSER_END(Jagger)

// Characters to ignore.
SKIP: { " " | "\r" | "\t" }

// Token specifications.
TOKEN:
{
    < NUMBER: (<DIGIT>)+ ("." (<DIGIT>)*)? >  // A decimal number.
|   < DIGIT: ["0"-"9"] >                      // A decimal digit.
|   < EOL: "\n" >                           // End of line.
//|   < LETTER: ["a"-"z","A"-"Z"] ( (" ")* ["a"-"z","A"-"Z","0"-"9"] )* >
|   < STRING: "\"" (~["\""])* "\"">
}

// Main lopp: read expressions on a line until end of file.
//     mainloop â†’ (expression <EOL>)* <EOF>
void mainloop():
{ Exp a; }
{
    (
      a=expression() <EOL> { a.prettyPrint(); }
      | "print(" a=expression() ")" <EOL> { Eval e = new Eval();
                                            TypeChecker t = new TypeChecker();
                                            a.accept(t);
                                            a.accept(e);
                                            System.out.println(""+e.getValue());}
    )*
    <EOF>
}


// Expression (the axiom).
// E -> T ('+'T | '-'T)*
Exp expression():
{ Exp a; }
{
    a=expressionOne() { return a; }
}


// Term.
// T -> F ('*'F | '/'F)*
Exp expressionOne():
{ Exp a,b; }
{
    a=expressionTwo()
    (
    "=="   b = expressionOne() { return new Equals(a,b);     }
    |"!="  b = expressionOne() { return new Different(a,b);  }
    )? { return a; }
}

Exp expressionTwo():
{ Exp a,b; }{
  a=expressionThree()
  (
    "<"   b = expressionTwo() { return new LessThan(a,b);     }
    |"<=" b = expressionTwo() { return new LessOrEqual(a,b);  }
    |">=" b = expressionTwo() { return new GreaterOrEqual(a,b); }
    |">"  b = expressionTwo() { return new GreaterThan(a,b);    }
  )? { return a; }
}

Exp expressionThree():
{ Exp a,b; }{
  a=expressionFour()
  (
    "+" b=expressionThree() { return new Add(a,b); }
  | "-" b=expressionThree() { return new Sub(a,b); }
  )? { return a; }
}

Exp expressionFour():
{ Exp a,b; }{
  a=expressionFive()
  (
    "*" b=expressionFour() { return new Mult(a,b); }
  | "/" b=expressionFour() { return new Div(a,b); }
  )? { return a; }
}

Exp expressionFive():
{ Exp a; }{
  a=expressionSix() { return a; }
  | "-" a=expressionSix()    { return new Negative(a);}
  | "+" a=expressionSix()     { return new Positive(a);}

}
// Factor of an expression.
// F -> <NUMBER> | "(" E ")"

Exp expressionSix():
{ Exp a; Exp b,c,d; }
{
      a=expressionSeven() {return a;}
      | "if" "(" b = expression() ")" "then""(" c = expression() ")" "else" "(" d = expression() ")"  {return new IfThenElse(b,c,d);}
}


Exp expressionSeven():
{ Token t; Exp e; }
{
    t=<STRING> { return new Strexp(t.toString());}
    |  t=<NUMBER> { return new Int(Integer.parseInt(t.toString())); }
    | "(" e=expression() ")" { return e; }

}
